# 0.4 認証・セキュリティ技術選定理由（評価項目付き）

---

## 1. JWT認証（JSON Web Token）

- **採用理由**
  - クライアント側でトークン保持のためサーバー負荷が少ない
  - フロント・バック分離アプリケーションに適している
  - Swagger UIで簡単にAPIテスト可能
  - 将来的なOAuth2連携も容易
- **評価項目**
  - 実装容易性（ログイン・ログアウト）
  - セキュリティ（トークン保護）
  - 拡張性（外部ログイン対応）
  - MVP工数（低〜中）

---

## 2. Cookieセッション認証

- **採用理由**
  - サーバー側でセッション管理可能で簡単にログイン制御できる
  - CSRF対策などセキュリティ機構を組み込みやすい
- **評価項目**
  - 実装容易性（ログイン・ログアウト）
  - セキュリティ（セッション保護・CSRF対策）
  - 拡張性（OAuth2連携可）
  - MVP工数（中）

---

## 3. OAuth2 / 外部認証（Google, GitHub 等）

- **採用理由**
  - パスワード管理不要でセキュア
  - 外部アカウントで認証できるため利便性が高い
- **評価項目**
  - 実装容易性（初期設定やエラー対応）
  - セキュリティ（外部プロバイダに依存）
  - 拡張性（複数プロバイダ追加可能）
  - MVP工数（高）

---

## 4. Firebase Authentication（BaaS）

- **採用理由**
  - クラウドサービスによる認証で実装工数が低い
  - メール認証やソーシャルログインに対応可能
- **評価項目**
  - 実装容易性（API呼び出しだけで簡単に導入）
  - セキュリティ（クラウド依存）
  - 拡張性（ソーシャルログイン対応）
  - MVP工数（低〜中）

---

## 5. 個人開発MVP向け総括

- **最小工数で自前管理 → JWT + bcrypt**
- **サーバーサイドで簡単管理 → Cookieセッション**
- **外部連携で豪華に見せる → OAuth2 / Firebase（MVPでは非推奨）**

---

## 6. 最終採用：JWT + Cookie 方式

### 採用理由

当初は Cookie ベースのセッション認証を検討したが、将来の拡張性を考慮し **JWT + Cookie** を採用する。

#### **JWT を選択した理由**

1. **拡張性の確保**
   - モバイルアプリ対応時に Bearer トークン方式へ容易に移行可能
   - API 外部公開時にも同じ認証基盤を使用可能
   - フロントエンド分離（SPA）に適している

2. **ステートレス設計**
   - サーバー再起動時の影響が最小限
   - 複数インスタンスへのスケーリングが容易
   - セッションストレージの管理負荷がない

3. **実装コストの妥当性**
   - Cookie セッションとの実装差は約 20 分程度
   - ブラックリスト管理で Redis を使用するため、インフラ追加なし
   - トークン無効化も実装可能（ブラックリスト方式）

#### **Cookie に保存する理由**

1. **XSS 対策**
   - HttpOnly Cookie により JavaScript からのアクセス不可
   - localStorage に保存する方式より安全

2. **実装の簡潔さ**
   - ブラウザが自動的に Cookie を送信
   - フロントエンドで Authorization ヘッダー管理不要

3. **CSRF 対策**
   - SameSite=Lax により基本的な CSRF を防御

#### **トレードオフの認識**

- トークン無効化に Redis ブラックリストが必要（完全なステートレスではない）
- ログアウト時の即座無効化とのバランスを取った設計

### 実装スコープ

**MVP：**
- アクセストークンのみ（24時間有効）
- ブラックリスト方式のトークン無効化
- bcrypt によるパスワードハッシュ

**Phase 2 以降：**
- リフレッシュトークン実装（1時間 + 7日間）
- 自動ログイン UX の向上
- トークン有効期限の短縮
