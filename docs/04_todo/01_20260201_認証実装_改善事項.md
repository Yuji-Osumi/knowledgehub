# 認証実装 改善事項

## フェーズ 6.4（ユーザー管理）レビュー後の改善タスク

---

## 1. created_by/updated_by の初期化方法の改善

**現在の実装：**
```python
# backend/app/api/auth.py
new_user = User(
    email=request.email,
    password_hash=hash_password(request.password),
    display_name=request.display_name,
    created_by=0,  # 仮の値（後で自分のIDに更新）
    updated_by=0,
)
db.flush()
new_user.created_by = new_user.id  # 自分のIDに更新
new_user.updated_by = new_user.id
db.commit()
```

**問題点：**
- トリッキーな実装（flush → 更新 → commit の2段階）
- `created_by=0` が一時的に不正な FK 参照を持つ
- コード可読性が低い

**推奨改善策：**

### オプション A: データベース制約の変更（推奨）
```sql
-- Alembic マイグレーション
ALTER TABLE users ALTER COLUMN created_by DROP NOT NULL;
ALTER TABLE users ALTER COLUMN updated_by DROP NOT NULL;
ALTER TABLE users ADD CONSTRAINT fk_created_by 
    FOREIGN KEY (created_by) REFERENCES users(id) DEFERRABLE;
```

```python
# backend/app/api/auth.py（簡潔化）
new_user = User(
    email=request.email,
    password_hash=hash_password(request.password),
    display_name=request.display_name,
    # created_by, updated_by は NULL 許可 or DB トリガーで設定
)
db.add(new_user)
db.flush()
new_user.created_by = new_user.id
new_user.updated_by = new_user.id
db.commit()
```

### オプション B: DB トリガーで自動設定
```sql
CREATE OR REPLACE FUNCTION set_self_audit_fields()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.created_by IS NULL THEN
        NEW.created_by := NEW.id;
    END IF;
    IF NEW.updated_by IS NULL THEN
        NEW.updated_by := NEW.id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER user_self_audit
BEFORE INSERT ON users
FOR EACH ROW EXECUTE FUNCTION set_self_audit_fields();
```

**優先度：** 中（フェーズ 6.6 以降で実装）

**影響範囲：**
- Alembic マイグレーションファイル
- User モデル定義（nullable 設定）
- signup エンドポイント（簡潔化）

---

## 2. UUID → str の変換を自動化

**現在の実装：**
```python
# backend/app/api/auth.py
user_response = UserResponse(
    public_id=str(new_user.public_id),  # 手動変換
    email=new_user.email,
    display_name=new_user.display_name,
)

# backend/app/core/redis_manager.py
session_data = {
    "user_id": str(user_id),  # 手動変換
    "exp_timestamp": exp_timestamp,
}
```

**問題点：**
- 複数箇所で `str()` を手動実行
- 変換忘れのリスク
- コード重複

**推奨改善策：**

### オプション A: Pydantic の JSON エンコーダー設定（推奨）
```python
# backend/app/schemas/auth.py
from uuid import UUID
from pydantic import BaseModel, ConfigDict

class UserResponse(BaseModel):
    model_config = ConfigDict(
        from_attributes=True,
        json_encoders={UUID: str}  # UUID 自動変換
    )
    
    public_id: str  # 実際は UUID でもOK
    email: str
    display_name: str
```

```python
# backend/app/api/auth.py（簡潔化）
user_response = UserResponse.model_validate(new_user)  # 自動変換
```

### オプション B: カスタム Field Serializer
```python
from pydantic import field_serializer

class UserResponse(BaseModel):
    public_id: UUID  # 型は UUID のまま
    
    @field_serializer('public_id')
    def serialize_uuid(self, value: UUID) -> str:
        return str(value)
```

**優先度：** 低（動作に影響なし、リファクタリング）

**影響範囲：**
- backend/app/schemas/auth.py（Pydantic 設定）
- backend/app/api/auth.py（変換コード削減）

---

## 3. Redis エラーログの情報拡充

**現在の実装：**
```python
# backend/app/api/auth.py
except Exception as redis_error:
    logger.error(f"Session creation failed: {type(redis_error).__name__}")
```

**問題点：**
- エラータイプのみ記録
- トラブルシューティングに必要な情報不足
- どのユーザーで失敗したか不明

**推奨改善策：**

### 構造化ログの導入
```python
# backend/app/api/auth.py
except Exception as redis_error:
    logger.error(
        "Redis session creation failed",
        extra={
            "user_id": str(new_user.public_id),
            "email": new_user.email,  # 機密情報の場合はハッシュ化
            "error_type": type(redis_error).__name__,
            "error_message": str(redis_error),
            "session_id_attempted": session_id,
            "redis_url": settings.REDIS_URL.split('@')[-1],  # ホスト部分のみ
        },
        exc_info=True
    )
```

### ログ集約ツール対応
```python
# backend/app/core/logging.py
import structlog

logger = structlog.get_logger()

# 使用例
logger.error(
    "session_creation_failed",
    user_id=user_id,
    error=type(error).__name__,
)
```

**優先度：** 低（本番運用時に有用）

**影響範囲：**
- backend/app/api/auth.py（ログ記録箇所）
- backend/app/core/logging.py（構造化ログ設定）
- requirements.txt（structlog 追加）

---

## 4. その他の改善提案

### 4.1. 依存性注入の統一

**現状：**
```python
from app.core.redis_manager import redis_manager  # グローバル参照
```

**推奨：**
```python
# backend/app/core/redis_manager.py
def get_redis_manager():
    return RedisSessionManager(settings.REDIS_URL)

# backend/app/api/auth.py
async def signup(
    request: SignupRequest,
    db: Session = Depends(get_db),
    redis: RedisSessionManager = Depends(get_redis_manager),  # DI
):
```

**メリット：**
- テスト時のモック化が容易
- 依存関係が明示的

**優先度：** 低（フェーズ 6.8 テスト実装時に検討）

### 4.2. レート制限の実装

**推奨：**
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/signup")
@limiter.limit("5/minute")  # 1分間に5回まで
async def signup(...):
```

**優先度：** 中（フェーズ 6.7 CORS・エラーハンドリング時に実装）

---

## 5. 追加の改善提案

### 5.1. セッション同時実行数の制限

**目的：** ユーザーが複数デバイスから同時にログインできるのを制限

**現状：** 制限なし（複数セッションが同時に存在可能）

**推奨実装：**
```python
# backend/app/core/redis_manager.py
def create_session(self, user_id: UUID, ttl_hours: int = 24, allow_multiple: bool = False):
    """
    セッション作成時に同時実行数をチェック
    allow_multiple=False: 前のセッションを無効化
    """
    if not allow_multiple:
        # 既存セッションを検索して削除
        user_sessions = self._redis.keys(f"user:{user_id}:*")
        for session_key in user_sessions:
            self._redis.delete(session_key)
    
    # 新セッション作成...
```

**優先度：** 中（フェーズ 6.5 ログイン実装時に検討）

**実装工数：** 1h

---

### 5.2. メール検証フロー（将来機能）

**目的：** 登録後にメールアドレスの有効性を確認

**現状：** EmailStr バリデーションのみ

**推奨実装（MVP後）：**
```python
# backend/app/models/user.py
class User(Base):
    email_verified: bool = False
    email_verification_token: Optional[str] = None
    email_verification_expires: Optional[datetime] = None

# backend/app/api/auth.py
async def signup(request: SignupRequest, db: Session, email_service: EmailService):
    user = User(..., email_verified=False)
    token = secrets.token_urlsafe(32)
    user.email_verification_token = hash_password(token)  # トークンをハッシュ化
    
    await email_service.send_verification_email(user.email, token)
    # ユーザーはメール確認まで機能制限
```

**優先度：** 低（MVP では実装不要、Phase 7+ で検討）

**実装工数：** 4h

---

### 5.3. パスワードリセットフロー（必須機能）

**目的：** パスワード忘れた場合の対応

**推奨実装：**
```python
# backend/app/models/user.py
class PasswordResetToken(Base):
    user_id: UUID = ForeignKey("users.id")
    token: str  # ハッシュ化
    expires_at: datetime
    used_at: Optional[datetime] = None

# backend/app/api/auth.py
@router.post("/forgot-password")
async def forgot_password(email: EmailStr, db: Session, email_service: EmailService):
    user = db.query(User).filter(User.email == email).first()
    if user:
        token = secrets.token_urlsafe(32)
        reset = PasswordResetToken(
            user_id=user.id,
            token=hash_password(token),
            expires_at=datetime.utcnow() + timedelta(hours=1)
        )
        db.add(reset)
        db.commit()
        await email_service.send_reset_email(email, token)
    
    # セキュリティ：ユーザー存在有無を隠す
    return {"message": "Reset link sent if email exists"}

@router.post("/reset-password")
async def reset_password(token: str, new_password: str, db: Session):
    reset = db.query(PasswordResetToken).filter(
        PasswordResetToken.expires_at > datetime.utcnow()
    ).first()
    
    if reset and verify_password(token, reset.token):
        user = db.get(User, reset.user_id)
        user.password_hash = hash_password(new_password)
        reset.used_at = datetime.utcnow()
        db.commit()
        return {"message": "Password reset successfully"}
```

**優先度：** 高（Phase 7 で実装）

**実装工数：** 3h

---

### 5.4. ブルートフォース攻撃対策

**目的：** ログイン試行回数を制限してアカウント乗っ取り防止

**現状：** 制限なし

**推奨実装：**
```python
# backend/app/core/redis_manager.py
class RedisSessionManager:
    def record_failed_login(self, email: str, max_attempts: int = 5, lockout_minutes: int = 15):
        """ログイン失敗回数を記録"""
        key = f"login_attempts:{email}"
        attempts = self._redis.incr(key)
        
        if attempts == 1:
            self._redis.expire(key, lockout_minutes * 60)
        
        if attempts >= max_attempts:
            # アカウントロック
            lockout_key = f"account_locked:{email}"
            self._redis.setex(lockout_key, lockout_minutes * 60, "1")
            raise AccountLockedError(f"Account locked for {lockout_minutes} minutes")
        
        return attempts
    
    def clear_failed_login(self, email: str):
        """ログイン成功時に失敗回数をリセット"""
        self._redis.delete(f"login_attempts:{email}")

# backend/app/api/auth.py
@router.post("/login")
async def login(request: LoginRequest, db: Session, redis: RedisSessionManager):
    try:
        user = db.query(User).filter(User.email == request.email).first()
        if not user or not verify_password(request.password, user.password_hash):
            redis.record_failed_login(request.email)
            raise UnauthorizedError("Invalid credentials")
        
        redis.clear_failed_login(request.email)
        # セッション作成...
    except AccountLockedError:
        logger.warning(f"Account locked: {request.email}")
        raise HTTPException(status_code=429, detail="Account temporarily locked")
```

**優先度：** 中（フェーズ 6.7 に含める）

**実装工数：** 1.5h

---

### 5.5. セッションの暗号化と署名

**目的：** Redis に保存されたセッションデータの改ざん防止

**現状：** JSON をそのまま保存

**推奨実装：**
```python
from cryptography.fernet import Fernet
import json

class RedisSessionManager:
    def __init__(self, redis_url: str, session_secret: str):
        self._redis = redis.from_url(redis_url, decode_responses=True)
        self._cipher = Fernet(session_secret.encode())
    
    def create_session(self, user_id: UUID, ttl_hours: int = 24):
        session_data = {
            "user_id": str(user_id),
            "exp_timestamp": int(time.time()) + ttl_hours * 3600,
        }
        # JSON を暗号化して保存
        encrypted = self._cipher.encrypt(
            json.dumps(session_data).encode()
        ).decode()
        
        session_id = secrets.token_hex(16)
        self._redis.setex(
            f"session:{session_id}",
            ttl_hours * 3600,
            encrypted
        )
        return session_id
    
    def get_session(self, session_id: str) -> dict:
        encrypted = self._redis.get(f"session:{session_id}")
        if not encrypted:
            return None
        
        try:
            decrypted = self._cipher.decrypt(encrypted.encode())
            return json.loads(decrypted)
        except Exception:
            # 改ざん検出
            return None
```

**優先度：** 低（本番環境では推奨、Phase 8 セキュリティ強化時）

**実装工数：** 2h

---

### 5.6. セッション無効化時の暗号化キャッシュクリア

**目的：** ログアウト後にキャッシュやブラウザキャッシュを確実にクリア

**現状：** Cookie と Redis セッションをクリアするのみ

**推奨実装：**
```python
# backend/app/api/auth.py
@router.post("/logout")
async def logout(request: Request, db: Session, redis: RedisSessionManager):
    session_id = request.cookies.get("session_id")
    
    if session_id:
        redis.delete_session(session_id)
    
    response = JSONResponse(
        {"message": "Logged out successfully"},
        status_code=204
    )
    # Cookie をクリア（Max-Age=0）
    response.delete_cookie(
        key="session_id",
        httponly=True,
        secure=True,
        samesite="lax",
        path="/"
    )
    
    # キャッシュコントロールヘッダを追加
    response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, proxy-revalidate"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "0"
    
    return response
```

**優先度：** 中（フェーズ 6.5 ログアウト実装時に含める）

**実装工数：** 0.5h

---

## 実装タイムライン

| フェーズ | 改善項目 | 優先度 | 推定工数 |
|---------|---------|--------|---------|
| 6.5（ログイン・ログアウト） | セッション同時実行制限 | 中 | 1h |
| 6.5（ログイン・ログアウト） | ログアウト時のキャッシュクリア | 中 | 0.5h |
| 6.7（CORS・エラー） | レート制限実装 | 中 | 2h |
| 6.7（CORS・エラー） | ブルートフォース攻撃対策 | 中 | 1.5h |
| 6.8（テスト） | UUID 自動変換 | 低 | 1h |
| Phase 7 | メール検証フロー | 低 | 4h |
| Phase 7 | パスワードリセット | 高 | 3h |
| Phase 8（セキュリティ強化） | セッション暗号化 | 低 | 2h |
| 本番準備 | created_by 制約変更 | 中 | 2h |
| 本番準備 | 構造化ログ導入 | 低 | 3h |

**合計推定工数：** 20h
- **フェーズ 6.5-6.8 含まれる:** 9h
- **Phase 7 以降:** 11h

---

## 関連ドキュメント

- [WBS_認証実装.md](../02_設計/WBS_認証実装.md)
- [06_セキュリティ方針（MVP）.md](../03_実装方針/06_セキュリティ方針（MVP）.md)
- [07_ログ設計.md](../03_実装方針/07_ログ設計.md)

---

**最終更新：** 2026-02-01  
**レビュアー：** GitHub Copilot  
**ステータス：** 承認待ち
